{"meta":{"title":"冰点","subtitle":"","description":"","author":"冰点","url":"https://ibingdian.github.io","root":"/"},"pages":[{"title":"about","date":"2020-05-11T17:27:31.000Z","updated":"2020-05-11T18:20:04.000Z","comments":true,"path":"about/index.html","permalink":"https://ibingdian.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-11T17:28:33.000Z","updated":"2020-05-11T17:28:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://ibingdian.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java面试","slug":"Java面试","date":"2020-05-11T19:02:31.060Z","updated":"2020-03-23T10:37:58.000Z","comments":true,"path":"2020/05/12/Java面试/","link":"","permalink":"https://ibingdian.github.io/2020/05/12/Java%E9%9D%A2%E8%AF%95/","excerpt":"","text":"1、Java1、对象的创建 1、直接引用：直接指向target的地址；target，可以是类、方法、字段… 2、符号引用：定义在class文件的常量池里面；以一个符号描述target，可以使用全类名描述类|接口，以名字描述方法|字段； 1、在编译的时候，是没有办法知道target的地址的。但是，可以在类的解析阶段，将符号引用替换成直接引用。 2、在类的解析阶段，那些不能被重写的方法可以直接替换，比如静态方法、私有方法、实例构造方法、final方法。 3、在调用方法的时候，会根据直接引用（符号引用）到对应类的常量池中找到对应的方法的元数据，根据元数据，创建栈帧。 4、在加载阶段，并不是所有的符号引用都能够被替换，有些在运行时才能被替换。 5、动态连接的作用是将符号引用转变成直接引用。 1、class文件的格式魔数、版本号、字段、方法、常量池。 常量池中主要包括了： ​ 字面量：Java语言层面的常量（字符串、final修饰的常量) ​ ==符号引用==：类|接口的全限定名、字段|方法的名称和数据类型 2、Java内存区域程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。 1、在JDK1.8之后，元空间替代了永久代，为什么移除了永久代？ 移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。 2、JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 3、方法区、运行时常量池区别？ 方法区：类的元数据、常量、静态变量 运行时常量池：？？？ Java中的常量，实际上分为两种形态：==静态常量池和运行时常量池== 1）所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 2）而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 3、对象的格式对象头（hashcode、gc分代年龄、类型指针、锁信息）、实例的数据、对齐填充 对象的起始地址是8字节的整数倍，当实例数据没有对其的时候…… 4、类加载器的种类和机制启动、扩展、系统；全盘负责、双亲委托 类加载的时候，先委托父类去加载，父类加载不了，自己才去加载； 避免了类的重复加载&核心API被修改。 5、类是怎么被加载的加载（1、2、3）、连接（验证、准备、==解析==）、初始化 6、对象是怎么创建的类加载检查、分配内存、初始化零值、设置对象头、执行方法 、 分配内存两种方式： 指针碰撞：使用一个指针表示那一块是分配过的，哪一块是没分配的，配置内存的时候，只有移动指针的位置；内存是规整的； 空闲列表：在一个列表里记录哪些内存是没有分配过的，分配内存的时候，是在一块足够大的地方分配内存，然后在更新列表；内存不规整。 内存分配并发问题： CAS失败重试、tlab（在伊甸区为每个线程分配内存） 7、对象是怎么被销毁的？引用计数法、==可达性分析法==、两次标记过程、 引用（强、软、弱、虚）、 分代收集算法、复制算法、标记清除法； 将堆内存分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。 Minor GC、Major GC/Full GC。 serial ：stop the world 8、对象的访问方式、优缺点句柄、直接指针 2、多线程内存模型：主内存、工作内存 1、线程的状态2、volatile、原子操作、synchronized的区别可见性、禁止指令集重排序； 原子操作类：boolean、int、long……volatile+cas； 对象头、moniter 线程状态切换 3、ReentrantLock、synchronized的区别区别（不响应中断、选择性通知）、原理 JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。 JDK1.6之后JVM官方对锁做了较大优化：引入了：锁粗化、锁消除、适应性自旋；同时增加了两种锁的状态：偏向锁、轻量锁 ReentrantReadWriteLock 4、并发流程控制工具CountDownLatch、CyclicBarrier、Semaphore 5、线程池ThreadPoolExecutor 为什么使用线程池、工作流程 6、ThreadLocalHASH_INCREMENT = 0x61c88647，它可以保证哈希吗均匀的分布在2的N次方数组里每当创建 ThreadLocal 实例时这个值都会增加一个HASH_INCREMENT。 开放地址法 7、ConcurrentHashMap数组里面的元素都加锁了 3、基础1、CAS 无锁算法，不加锁的情况下实现多线程变量的同步。 2、RPC 3、SPI 服务发现 4、hash函数+避免冲突 保证哈希吗均匀的分布 拉链法，hashmap 1[ h ^ ( h >>> 16 ) ] & ( n-1 ) 开放地址法 HASH_INCREMENT = 0x61c88647 1threadLocalHashCode & (n-1) 5、动态代理 jdk-Proxy、InvocationHandler cglib-Enhancer、Callback 6、生产者消费者模式 2、基础1、NIOsocket BIO NIO select、epoll 轮询select 1024 1、在一个线程里，轮询选择器select()：系统调用，直到有事件才返回，否则一直阻塞； 2、一个选择器会管理多个通道上的事件，当有事件发生时，会从缓冲区拿事件； 比如，ServerSocketChannel会在选择器上注册连接事件，当事件发生时，select会返回，我们可以从缓冲区拿到事件，创建一个SocketChannel，并往选择器上注册一个读写事件…… reactor模型——事件驱动，Reactor 、Acceptor、Handlers 2、HTTPhttp & https & websocket & http21、三次握手、四次挥手 2、明文|加密（how） 共享密钥、公开密钥 3、实时更新、冗余数据太多 WS 三次握手之后，客户端发起协议升级的请求： 1234567GET / HTTP/1.1Host: localhost:8080Origin: http://127.0.0.1:3000Connection: UpgradeUpgrade: websocketSec-WebSocket-Version: 13Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw== 服务器收到之后，会发送101，表示完成了协议的升级： 1234HTTP/1.1 101 Switching ProtocolsConnection:UpgradeUpgrade: websocketSec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU= 80|443 cache-control、last-modify，if-modify-since、etag、if-match accept-* cors cookie 3、数据库1、结构页、行结构、存储引擎、server 2、索引1、联合索引、聚簇索引、前缀索引 索引部分有效 2、怎么利用索引？ SELECT语句务必指明字段名称、 使用inner join、 索引列的类型尽量小、 超过三张表禁止join、 自增id、 在where子句中应该避免： ​ 对字段进行表达式、函数操作 、 ​ 使用变量、 ​ 使用!=、、 ​ 使用or、not in、 ​ 使用空值进行判断，is null ​ 使用%ike模糊查询 避免隐式类型转换 、 3、操作1、连接join buffer 2、子查询in子查询 ​ 半连接、物化、exists 4、MyISAM和InnoDB的区别5、锁表锁、行锁、乐观锁、悲观锁） 6、事务特点，快照读、当前读，隔离级别 对于不相关的IN子查询来说，如果单独执行子查询后的结果集太多的话，就会导致这些问题： 1、结果集太多，可能内存中都放不下 ； 2、对查询优化器使用索引，就会有问题。 对于外层查询来说，如果子查询的结果集太多，那就意味着IN子句中的参数特别多，这会导致： 无法有效的使用索引，只能对外层查询进行全表扫描。 在对外层查询执行全表扫描时，由于IN子句中的参数太多，这会导致检测一条记录 是否符合和IN子句中的参数匹配花费的时间太长。 SQL语句中IN包含的值不应过多，不能超过200个200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本;另外建议能用between就不要用in，这样就可以使用range索引了； 如果in不能用到索引，可以改成exists看是否能用到索引 ； type、possible_keys、key、Extra 死锁 MVCC 4、数据结构数组、链表、栈、队列、树（二叉树、满二叉树、完全二叉树、二叉查找树、堆）的特性 —————————————————————————————— 二叉查找树 查询最大值/最小值/任意值、插入/删除操作 ——>O(log(n)) 平衡二叉树， —————————————————————————————— 堆 查询最大值/最小值 ——>O(1) 查询任意值 ——>O(n) 插入/删除操作 ——>O(log(n)) —————————————————————————————— 1、堆排序（最大堆）： 1、创建堆 从最后一个非叶子节点开始依次执行【下沉】操作； 2、排序 循环删除堆顶元素； 并把最后一个元素放到堆顶，执行【下沉】操作； —————————————————————————————— 2、最大优先队列 插入 先放到最后一个位置，执行【上浮】操作； 删除 删除堆顶元素；把最后一个元素放到堆顶，执行【下沉】操作； —————————————————————————————— 二分查找 5、设计模式1、创建对象的模式1、单例模式内存中只有一个实例； 2、==构建者模式==同样的构建过程就可以构建不同的产品。 3、工厂模式在工厂中创建对象； 工厂方法模式：有多个工厂 静态工厂模式：有一个工厂 抽象工厂模式：一个工厂创建多个对象 2、结构类的模式组合类或者对象 1、==适配器==用来解决两个系统之间接口不兼容的问题。可以把别的系统特殊的、新加的类，封装成我们系统里面一个正在使用的类。这样，我们的系统基本不用修改，所有的调用跟以前一样。 2、代理模式使用代理对象增强目标对象的方法，区别是可以条件判断，是否调用目标方法；装饰模式：仅仅侧重增强目标对象的方法； 3、门面模式一个供外部访问的接口；外部通过这个接口就可以访问这个系统。可以减少系统间的相互依赖。 3、行为类模式1、观察者模式定义对象间一对多的依赖关系，当一个对象发生改变，它所依赖的对象也会受到通知。 2、模板方法模式定义一个框架，将某些步奏的具体实现，放到子类里面去做。 3、责任链模式==一个请求可以有多个对象处理==，这些对象连成一条链，并沿着这个链传递请求，如果一个对象不能处理，就把这个事件传递到下一个对象，直到有对象可以处理为止。 4、策略模式策略封装类不用实现策略接口，可以随意切换不同策略。 3、服务端框架1、spring1、基础1、IoC微观上，Spring ioc容器就是 singletonObjects： Map singletonObjects = new ConcurrentHashMap(256); 宏观上，指整个Spring环境，bean工厂：dbMap，处理器、singletonObjects 2、AOP处理横切性的问题，日志记录\\事务\\异常\\权限检查，和主业务逻辑分开，降低耦合、减小重复代码。 使用动态代理对目标方法进行增强 1、术语1、连接点、切点、增强|通知、切面、织入 2、通知类型 3、execution、@annotation、this、target 2、原理1、初始化@EnableAspectJAutoProxy ——> 注册BeanPostProcessor 2、获取切面的描述信息在bean实例化之前 3、生成代理对象在bean实例化之后；会判断当前类有没有在哪个切点里面； 我们可以看到， 1、默认使用jdk动态代理； 2、但是如果目标类，没有接口，使用的将会是cglib； 3、如果目标类有接口，要使用cglib，可以修改proxyTargetClass=true，@EnableAspectJAutoProxy(proxyTargetClass = true)。 3、事务的传播行为1、required 2、requires_new 3、mandatory 强制的 4、never 5、supports 6、not_supported 4、其他1、ApplicationContext和BeanFactory区别ApplicationEventPublisher（消息发送）、ResourceLoader（加载资源） 2、BeanFactory和FactoryBean当一个类的依赖关系很复杂的时候，但是我们想对外提供一个简单方式，方便外部快速获取到，可以使用FactoryBean。 比如， SqlSessionFactory ————> SqlSessionFactoryBean ，配置类Configuration T ————> ReferenceBean，消费者 3、循环引用singletonFactories、singletonObjects 4、事件？ 怎么找？怎么给它？查找目标对象的方式：byname、bytype 属性注入的方式：set方法、构造器、field（反射） AUTOWIRE_NO ：默认不自动装配，@autowire注解调仍然会自动装配。 AUTOWIRE_BY_NAME：根据名字自动装配。AUTOWIRE_BY_TYPE：根据类型自动装配。 2、扩展点 @Import引入的两种接口： ImportSelector（Spring Boot 自动装配，引入AOP的BeanPostProcessor）、 ImportBeanDefinitionRegistrar（mybatis注册mapper，MapperFactoryBean） 后置处理器 1、ConfigurationClassPostProcessor（BeanDefinitionRegistryPostProcessor） ​ 1、扫描包，并把bean注册给beanFactory。 ​ 2、回调@Import相关的接口，注册@import引入的类。 ​ 3、为@Configuration类生成一个cglib代理。 2、BeanPostProcessor：在bean实例化之后、放到bean容器之前、插手bean的实例化过程 ​ bean的生命周期回调、AOP 3、spring.factories ​ 3、springMVC流程web框架，实现了一些servlet的API； ServletContainerInitializer#onStartUp|WebApplicationInitializer、 Servlet#init Servlet#service 1、初始化DispacherServlet1、< cinit> ——加载DispatcherServlet.properties; 2、——1、调用容器的onRefresh方法； 2、从上面这个对象中读取MultipartResolver、HandlerMapping、ViewResolver，设置给DispacherServlet……； 2、初始化HandlerMappingRequestMappingHandlerMapping（InitializingBean#afterPropertiesSet） 3、处理请求匹配、反射调用 Servlet#service ——> DispatcherServlet#doDispatch 4、渲染 InternalResourceViewResolver 4、springboot是一种快速使用spring的方式 1、约定大于配置、内嵌tomcat2、自动装配—— @EnableAutoConfiguration、ImportSelect接口、META-INF/spring.factories、 3、起步依赖 —— 比如，mybatis-spring-boot-starter、 4、启动流程1、SpringApplication#run —— 创建容器 —— 2、——OnRefresh —— 启动tomcat—— ​ —— 回调ServletContainerInitializer#onStartUp，设置dispatcherservlet ​ ——Servlet#init、 2、mybatis1、JDBC2、持久层框架避免sql语句硬编码、避免结果集解析的硬编码、连接池 3、动态sqlwhere、trim、if、foreach、#{}、${}——逻辑判断、动态拼接 sql 【【【【ognl】】】 主键自增、缓存、 延迟加载：会创建关联对象的代理对象，只有在关联对象被执行的时候，才去执行相关的sql； TypeHandler —— 映射Java对象到表的某一列上 Interceptor ，@Intercepts，指定拦截的类型、方法和参数列表 插件 ——Interceptor、@Intercepts， Executor插件： 以SimpleExecutor作为target，在获取sqlSession的时候，会遍历所有实现Interceptor接口的类，取出@Intercepts注解，并拿注解上配置的type和target的接口类型做对比，如果一致，则使用这个类为target创建一个jdk动态代理对象，并返回。 在调用的时候，会判断：如果为目标方法设置了插件，会调这些插件， 4、流程1、初始化SqlSessionFactory ——> SqlSession ——> T MappedStatement、MapperProxyFactory 2、执行代理对象—— 得到映射关系，主要是根据参数的顺序。 SqlSession——SqlSession#select —— 得到MappedStatement、执行executor 5、mybatis-springSqlSessionFactoryBean、MapperFactoryBean 可以把Java对象变成sql语句中的参数；也可以把sql语句执行的结果封装成Java对象； 封装了加载驱动、创建连接、创建statement、执行statement、映射结果集的过程。 模糊查询 like 语句该怎么写 ？ 1）在 java 中拼接通配符，通过#{}赋值 LIKE CONCAT('%',#{name},'%') 2）在 Sql 语句中拼接通配符 （不安全 会引起 Sql 注入） like '%${name}%' truncate、insert 3、dubbo1、SPI 、依赖注入（ ExtensionFactory、SpiExtensionFactory、SpringExtensionFactory） 2、调用流程： 服务调用：MockClusterInvoker 服务导出（Invoker：ProxyFactory#getInvoker（javassit），Protocol#export）、 服务发现（Invoker：Protocol#refer，ProxyFactory#getProxy（javassit——jdk动态代理） 客户端的代理对象(jdk代理)——>Invoker——>netty_________netty——>Invoker(Wrapper)——>服务端的真实对象 路由：调用的时候过滤调哪些机器 负载均衡：随机、轮询、相同调用数 随机、hash 容错： 协议：dubbo（NIO、长连接、hessian）、http、rest。。。 注册中心：ZK、redis。。。 ExtensionFactory 4、tomcat5、zookeeper1、简介服务治理 ZAB协议、领导者选举、写操作、 2、持久化（10 0000）、 3、集群集群的角色、节点的类型（节点之间是相互有序的，会自动在节点后面加一个整型数）、watch机制、 脑裂 4、使用分布式锁（Curator）、配置中心、命名服务 6、redis1、简介nosql、内存运行、单线程、IO多路复用、数据类型、|| 内存淘汰机制、过期策略 内存淘汰机制：volatile-lru：对设置了过期时间的key， 删除 最近最少使用的key（默认值）；allkeys-lru ： 对所有的key， 删除 最近最少使用的；volatile-random：对设置了过期时间的key，随机的删除 key；allkeys-random： 对所有的key，随机删除；volatile-ttl ： 删除即将过期的noeviction ： 永不过期，返回错误 事务，watch机制 1、避免使用keys 2、设置key有效期*3、想要一次添加多条数据的时候可以使用管道** 2、持久化rdb、aof、混合持久化 3、数据类型range、push、pop 3、集群主从模式（runid、offset）、哨兵模式、集群 （主从切换数据丢失——异步复制、脑裂，min-slave-to-write） psync 缓冲区：主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区，默认1M ； offset：主节点向从节点传递的字节数； 4、使用缓存、分布式锁 redis集群的哈希槽算法：哈希槽的个数是个固定值 16384 2^14 7、nettynetty 每个channel收到的IO事件，都会沿着一个链传递到每个ChannelHandler上，我们需要做的就是定义自己的ChannelHandler 8、其他 4、客户端 — 待续 1、web 2、android $$1+2+3+…+n\\leq n^{2}$$ $$n+\\frac{n}{2}+\\frac{n}{4}+…\\leq2n$$","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-11T16:51:53.360Z","updated":"2020-05-11T19:07:20.000Z","comments":true,"path":"2020/05/12/hello-world/","link":"","permalink":"https://ibingdian.github.io/2020/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment https://www.jianshu.com/p/390f202c5b0e 123hexo cleanhexo deploy","categories":[],"tags":[]}],"categories":[],"tags":[]}