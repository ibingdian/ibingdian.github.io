{"meta":{"title":"冰点","subtitle":"","description":"","author":"冰点","url":"https://ibingdian.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-11T17:28:33.000Z","updated":"2020-05-11T17:28:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://ibingdian.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2020-05-11T19:13:52.000Z","comments":true,"path":"about/index.html","permalink":"https://ibingdian.github.io/about/index.html","excerpt":"","text":"ly"}],"posts":[{"title":"Android消息机制-2","slug":"Android消息机制-2","date":"2020-05-12T11:45:17.100Z","updated":"2020-05-12T11:44:34.000Z","comments":true,"path":"2020/05/12/Android消息机制-2/","link":"","permalink":"https://ibingdian.github.io/2020/05/12/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-2/","excerpt":"","text":"1、概述Handler发送的消息，会被添加到MessageQueue中，在添加新消息的时候，可能会唤醒MessageQueue；Handler所在线程的那个Looper会循环从MessageQueue取消息，如果没有可以返回的消息，可能会挂起等待一段时间。 MessageQueue的挂起&唤醒，主要涉及到了一些native方法，如下 2、nativeInit()方法 在创建MessageQueue时，会调用nativeInit()方法，会在native层创建一个NativeMessageQueue对象，并返回一个指向NativeMessageQueue的指针。 在这个过程中，native层也创建了一个Looper对象。 3、nativePollOnce()方法总之，底层是通过epoll实现的，会阻塞调用线程，在超时或者被唤醒的时候返回； 如上所述，最终会调用Looper#pollOnce方法； 可以看到最终调用了pollInner方法： 4、nativeWake()方法在消息入队的时候，如果当前消息队列阻塞，并且当前入队的是一个非异步的Message，会调用nativeWake方法唤醒消息队列对应的线程来处理消息。 如下中可以看出，只要插入的Message不是异步的，那么needWake的值就会是mBlocked的值，而mBlocked的值会在出队方法next中、当线程阻塞的时候设为True。 从上面的nativeWake一路调用到MessageQueue中的wake然后到Looper中的wake。而在Looper中的wake，我们看到，使用write向mWakeEventFd中写入了一个uint64_t 的1。 与我们前面分析pollInner中的对应。在pollInner中，若是由于对应的文件描述符发生的事件，调用awoke清空文件，而awoke刚好就是读取一个uint64_t的值。 参考：Handler消息机制详解，另对于MessageQueue阻塞线程的详解","categories":[],"tags":[]},{"title":"Android消息机制-1","slug":"Android消息机制-1","date":"2020-05-12T11:45:17.090Z","updated":"2020-05-12T11:44:18.000Z","comments":true,"path":"2020/05/12/Android消息机制-1/","link":"","permalink":"https://ibingdian.github.io/2020/05/12/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-1/","excerpt":"","text":"1、概述Handler可以发送和处理消息； 每一个Handler实例会和一个Thread、Looper、message queue关联； 消息会被发送到message queue； Handler会发送消息到Looper的message queue，并在Looper的线程执行它。 Handler主要有两个用途： 在未来执行一个任务； 在别的线程执行一个任务； 消息的调度可以通过下面方法完成： post(Runnable), postAtTime(java.lang.Runnable, long), postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), sendMessageDelayed(Message, long)， 其中，sendMessageXXX()方法允许添加一个Message对象；postXXX()方法允许添加一个Runnable对象，Handler会将Runable包装成一个Message。 在主线程有一个message queue，负责管理顶级应用程序对象(activities, broadcast receivers, etc)和它们创建的任何窗口。在自己的线程里，可以通过Handler和主线程通信。 2、使用1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity { private Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void click(View view) { new Thread(new Runnable() { @Override public void run() { Message message = new Message(); message.what = 1; handler.sendMessage(message); } }).start(); }} 或者 123456789101112public class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); }} 3、原理1、MessageMessage是一个有序链表，在插入的时候，按照时间排序。 2、MessageQueue1、入队向有序链表中插入数据，以时间-when，作为排序的条件； ——小的在前面，大的在后面 注意：此处省略了一些代码，比如，唤醒线程 2、出队如果条件合适（message的时间小于当前时间），会返回一个Message；否则，挂起一段时间。 3、LooperLooper会循环从MessageQueue中取message，发给Handler 4、Handler1、发送消息可以调用sendMessageXXX()、postXXX()方法发送消息； 2、接收消息在合适的时间、地点，MessageQueue会将Message取出来，交给Handle去处理 5、总结1、Handler发送的消息，会被添加到MessageQueue中：其实就是追加到Message这个链表里； 2、Handler所在线程的那个Looper会循环从MessageQueue取消息，如果可以取出来就返回，将消息发送到Handler的回调方法中；否则挂起等待一段时间。 4、问题Message 会持有一个对 Handler 的引用，当这个 Handler 是非静态内部类的时候，又会持有一个对外部类的引用（比如Activity）。如果发送一条延时的 Message，由于这个 Message 会长期存在于队列中，就会导致 Handler 长期持有对 Activity 的引用，从而引起视图和资源泄漏。 下面我们来具体分析一下导致该问题的原因： 当 Android 应用首次启动时，framework 会在应用的 UI 线程创建一个 Looper 对象。Looper 实现了一个简单的消息队列并且一个接一个的处理队列中的消息。应用的所有事件（比如 Activity 生命周期回调方法，按钮点击等等）都会被当做一个消息对象放入到 Looper 的消息队列中，然后再被逐一执行。UI 线程的 Looper 存在于整个应用的生命周期内。当在 UI 线程中创建 Handler 对象时，它就会和 UI 线程中 Looper 的消息队列进行关联。发送到这个消息队列中的消息会持有这个 Handler 的引用，这样当 Looper 最终处理这个消息的时候 framework 就会调用 Handler 的 handleMessage(Message) 方法来处理具体的逻辑。在 Java 中，非静态的内部类或者匿名内部类会隐式的持有其外部类的引用，而静态的内部类则不会。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-11T16:51:53.360Z","updated":"2020-05-11T19:07:20.000Z","comments":true,"path":"2020/05/12/hello-world/","link":"","permalink":"https://ibingdian.github.io/2020/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment https://www.jianshu.com/p/390f202c5b0e 123hexo cleanhexo deploy","categories":[],"tags":[]}],"categories":[],"tags":[]}