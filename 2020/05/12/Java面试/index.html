<!DOCTYPE html>
<html>
  <head>
      <script>
  var _hmt = _hmt || []
  ;(function() {
    var hm = document.createElement('script')
    hm.src = 'https://hm.baidu.com/hm.js?5a0acc897fd96474a2c8f4deac84611a'
    var s = document.getElementsByTagName('script')[0]
    s.parentNode.insertBefore(hm, s)
  })()
</script> 
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    
    <title>
      Java面试 - 冰点
    </title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon" />
    
<link rel="stylesheet" href="/style/style.css">

  <meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <canvas id='pagemap'></canvas>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、Java"><span class="toc-text">1、Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、对象的创建"><span class="toc-text">1、对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、class文件的格式"><span class="toc-text">1、class文件的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Java内存区域"><span class="toc-text">2、Java内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、对象的格式"><span class="toc-text">3、对象的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、类加载器的种类和机制"><span class="toc-text">4、类加载器的种类和机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、类是怎么被加载的"><span class="toc-text">5、类是怎么被加载的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、对象是怎么创建的"><span class="toc-text">6、对象是怎么创建的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、对象是怎么被销毁的？"><span class="toc-text">7、对象是怎么被销毁的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、对象的访问方式、优缺点"><span class="toc-text">8、对象的访问方式、优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、多线程"><span class="toc-text">2、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、线程的状态"><span class="toc-text">1、线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、volatile、原子操作、synchronized的区别"><span class="toc-text">2、volatile、原子操作、synchronized的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、ReentrantLock、synchronized的区别"><span class="toc-text">3、ReentrantLock、synchronized的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、并发流程控制工具"><span class="toc-text">4、并发流程控制工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、线程池"><span class="toc-text">5、线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、ThreadLocal"><span class="toc-text">6、ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、ConcurrentHashMap"><span class="toc-text">7、ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、基础"><span class="toc-text">3、基础</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、基础"><span class="toc-text">2、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、NIO"><span class="toc-text">1、NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、HTTP"><span class="toc-text">2、HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-amp-https-amp-websocket-amp-http2"><span class="toc-text">http &amp; https &amp; websocket &amp; http2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、数据库"><span class="toc-text">3、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、结构"><span class="toc-text">1、结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、索引"><span class="toc-text">2、索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、操作"><span class="toc-text">3、操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、连接"><span class="toc-text">1、连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、子查询"><span class="toc-text">2、子查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、MyISAM和InnoDB的区别"><span class="toc-text">4、MyISAM和InnoDB的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、锁"><span class="toc-text">5、锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、事务"><span class="toc-text">6、事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、数据结构"><span class="toc-text">4、数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、设计模式"><span class="toc-text">5、设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、创建对象的模式"><span class="toc-text">1、创建对象的模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、单例模式"><span class="toc-text">1、单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、-构建者模式"><span class="toc-text">2、&#x3D;&#x3D;构建者模式&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、工厂模式"><span class="toc-text">3、工厂模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、结构类的模式"><span class="toc-text">2、结构类的模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、-适配器"><span class="toc-text">1、&#x3D;&#x3D;适配器&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、代理模式"><span class="toc-text">2、代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、门面模式"><span class="toc-text">3、门面模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、行为类模式"><span class="toc-text">3、行为类模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、观察者模式"><span class="toc-text">1、观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、模板方法模式"><span class="toc-text">2、模板方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、责任链模式"><span class="toc-text">3、责任链模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、策略模式"><span class="toc-text">4、策略模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、服务端框架"><span class="toc-text">3、服务端框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、spring"><span class="toc-text">1、spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、基础"><span class="toc-text">1、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、IoC"><span class="toc-text">1、IoC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、AOP"><span class="toc-text">2、AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、术语"><span class="toc-text">1、术语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、原理"><span class="toc-text">2、原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1、初始化"><span class="toc-text">1、初始化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2、获取切面的描述信息"><span class="toc-text">2、获取切面的描述信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3、生成代理对象"><span class="toc-text">3、生成代理对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、事务的传播行为"><span class="toc-text">3、事务的传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、其他"><span class="toc-text">4、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、ApplicationContext和BeanFactory区别"><span class="toc-text">1、ApplicationContext和BeanFactory区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、BeanFactory和FactoryBean"><span class="toc-text">2、BeanFactory和FactoryBean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、循环引用"><span class="toc-text">3、循环引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、扩展点"><span class="toc-text">2、扩展点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、springMVC流程"><span class="toc-text">3、springMVC流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、初始化DispacherServlet"><span class="toc-text">1、初始化DispacherServlet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、-lt-cinit-gt-——"><span class="toc-text">1、&lt; cinit&gt; ——</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、-lt-Servlet-init-gt-——"><span class="toc-text">2、——</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、初始化HandlerMapping"><span class="toc-text">2、初始化HandlerMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、处理请求"><span class="toc-text">3、处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、springboot"><span class="toc-text">4、springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、约定大于配置、内嵌tomcat"><span class="toc-text">1、约定大于配置、内嵌tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、自动装配"><span class="toc-text">2、自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、起步依赖"><span class="toc-text">3、起步依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、启动流程"><span class="toc-text">4、启动流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、mybatis"><span class="toc-text">2、mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、JDBC"><span class="toc-text">1、JDBC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、持久层框架"><span class="toc-text">2、持久层框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、动态sql"><span class="toc-text">3、动态sql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、流程"><span class="toc-text">4、流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、初始化-1"><span class="toc-text">1、初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、执行"><span class="toc-text">2、执行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、mybatis-spring"><span class="toc-text">5、mybatis-spring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、dubbo"><span class="toc-text">3、dubbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、tomcat"><span class="toc-text">4、tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、zookeeper"><span class="toc-text">5、zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、简介"><span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、持久化"><span class="toc-text">2、持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、集群"><span class="toc-text">3、集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、使用"><span class="toc-text">4、使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、redis"><span class="toc-text">6、redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、简介-1"><span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、持久化-1"><span class="toc-text">2、持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、数据类型"><span class="toc-text">3、数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、集群-1"><span class="toc-text">3、集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、使用-1"><span class="toc-text">4、使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、netty"><span class="toc-text">7、netty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、其他"><span class="toc-text">8、其他</span></a></li></ol></li></ol>
    </div>
    
    <div id="fixed-menu-wrap">
      <span class="iconfont icon-sousuo search-box menu-reset"></span>
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search" />
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpeg" />
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class="">
          首页
        </a>
        
        <a href="/archives" class="">
          归档
        </a>
        
        <a href="/about" class="">
          关于
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <div class="author">冰点</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">冰点</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class="">
            首页
          </a>
          
          <a href="/archives" class="">
            归档
          </a>
          
          <a href="/about" class="">
            关于
          </a>
          
          <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a>
        </div>
        <div class="bottom">
          <div class="follow">
             
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">Java面试</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2020/05/12</span>
        </span>

        

        
        
        
      </div>
      <div>
      </div>
    </div>
    <html><head></head><body><h1 id="1、Java">1、Java<a class="post-anchor" href="#1、Java"></a></h1><h2 id="1、对象的创建">1、对象的创建<a class="post-anchor" href="#1、对象的创建"></a></h2><hr>
<hr>
<p>1、直接引用：直接指向target的地址；target，可以是类、方法、字段…</p>
<p>2、符号引用：定义在class文件的常量池里面；以一个符号描述target，可以使用全类名描述类|接口，以名字描述方法|字段；</p>
<hr>
<p>1、在编译的时候，是没有办法知道target的地址的。但是，可以在类的解析阶段，<u>将符号引用替换成直接引用</u>。</p>
<p>2、在类的解析阶段，那些不能被重写的方法可以直接替换，比如静态方法、私有方法、实例构造方法、final方法。</p>
<p>3、在调用方法的时候，会根据直接引用（符号引用）到对应类的常量池中找到对应的方法的元数据，根据元数据，创建栈帧。</p>
<p>4、在加载阶段，并不是所有的符号引用都能够被替换，有些在运行时才能被替换。</p>
<p>5、动态连接的作用是将符号引用转变成直接引用。</p>
<hr>
<hr>
<h3 id="1、class文件的格式">1、class文件的格式<a class="post-anchor" href="#1、class文件的格式"></a></h3><p>魔数、版本号、字段、方法、常量池。</p>
<p>常量池中主要包括了：</p>
<p>​    字面量：Java语言层面的常量（字符串、final修饰的常量)</p>
<p>​    ==符号引用==：类|接口的全限定名、字段|方法的名称和数据类型</p>
<h3 id="2、Java内存区域">2、Java内存区域<a class="post-anchor" href="#2、Java内存区域"></a></h3><p>程序计数器、Java虚拟机栈、本地方法栈、堆<运行时常量池>、方法区。</p>
<p>1、在JDK1.8之后，元空间替代了永久代，为什么移除了永久代？</p>
<p>移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p>
<p>2、JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
<p>3、方法区、运行时常量池区别？</p>
<p>方法区：类的元数据、常量、静态变量</p>
<p>运行时常量池：？？？</p>
<p><strong>Java中的常量</strong>，实际上分为两种形态：==<strong>静态常量池</strong>和<strong>运行时常量池</strong>==</p>
<p>  1）所谓<strong>静态常量池</strong>，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</p>
<p>  2）而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p>
<h3 id="3、对象的格式">3、对象的格式<a class="post-anchor" href="#3、对象的格式"></a></h3><p>对象头（hashcode、gc分代年龄、类型指针、锁信息）、实例的数据、对齐填充</p>
<p>对象的起始地址是8字节的整数倍，当实例数据没有对其的时候……</p>
<h3 id="4、类加载器的种类和机制">4、类加载器的种类和机制<a class="post-anchor" href="#4、类加载器的种类和机制"></a></h3><p>启动、扩展、系统；全盘负责、双亲委托</p>
<p>类加载的时候，先委托父类去加载，父类加载不了，自己才去加载；</p>
<p>避免了类的重复加载&核心API被修改。</p>
<h3 id="5、类是怎么被加载的">5、类是怎么被加载的<a class="post-anchor" href="#5、类是怎么被加载的"></a></h3><p>加载（1、2、3）、连接（验证、准备、==<u>解析</u>==）、初始化</p>
<h3 id="6、对象是怎么创建的">6、对象是怎么创建的<a class="post-anchor" href="#6、对象是怎么创建的"></a></h3><p>类加载检查、分配内存、初始化零值、设置对象头、执行<init>方法</init></p>
<p><new>、<init></init></new></p>
<p>分配内存两种方式：</p>
<p>指针碰撞：使用一个指针表示那一块是分配过的，哪一块是没分配的，配置内存的时候，只有移动指针的位置；内存是规整的；</p>
<p>空闲列表：在一个列表里记录哪些内存是没有分配过的，分配内存的时候，是在一块足够大的地方分配内存，然后在更新列表；内存不规整。</p>
<p>内存分配并发问题：</p>
<p>CAS失败重试、tlab（在伊甸区为每个线程分配内存）</p>
<h3 id="7、对象是怎么被销毁的？">7、对象是怎么被销毁的？<a class="post-anchor" href="#7、对象是怎么被销毁的？"></a></h3><p>引用计数法、==可达性分析法==、两次标记过程、</p>
<p>引用（强、软、弱、虚）、</p>
<p>分代收集算法、复制算法、标记清除法；</p>
<p>将堆内存分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>Minor GC、Major GC/Full GC。</p>
<p>serial ：stop the world</p>
<h3 id="8、对象的访问方式、优缺点">8、对象的访问方式、优缺点<a class="post-anchor" href="#8、对象的访问方式、优缺点"></a></h3><p>句柄、直接指针</p>
<h2 id="2、多线程">2、多线程<a class="post-anchor" href="#2、多线程"></a></h2><p>内存模型：主内存、工作内存</p>
<h3 id="1、线程的状态">1、线程的状态<a class="post-anchor" href="#1、线程的状态"></a></h3><h3 id="2、volatile、原子操作、synchronized的区别">2、volatile、原子操作、synchronized的区别<a class="post-anchor" href="#2、volatile、原子操作、synchronized的区别"></a></h3><p>可见性、禁止指令集重排序；</p>
<p>原子操作类：boolean、int、long……volatile+cas；</p>
<p>对象头、moniter</p>
<p>线程状态切换</p>
<h3 id="3、ReentrantLock、synchronized的区别">3、ReentrantLock、synchronized的区别<a class="post-anchor" href="#3、ReentrantLock、synchronized的区别"></a></h3><p>区别（不响应中断、选择性通知）、原理</p>
<p>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。</p>
<p>JDK1.6之后JVM官方对锁做了较大优化：引入了：锁粗化、锁消除、适应性自旋；同时增加了两种锁的状态：偏向锁、轻量锁</p>
<a href="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20191229144701491.png" data-caption="image-20191229144701491" data-fancybox="images"><img src="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20191229144701491.png" alt="image-20191229144701491"></a>

<a href="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20191229172311687.png" data-caption="image-20191229172311687" data-fancybox="images"><img src="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20191229172311687.png" alt="image-20191229172311687"></a>

<p>ReentrantReadWriteLock</p>
<h3 id="4、并发流程控制工具">4、并发流程控制工具<a class="post-anchor" href="#4、并发流程控制工具"></a></h3><p>CountDownLatch、CyclicBarrier、Semaphore</p>
<h3 id="5、线程池">5、线程池<a class="post-anchor" href="#5、线程池"></a></h3><p>ThreadPoolExecutor</p>
<p>为什么使用线程池、工作流程</p>
<h3 id="6、ThreadLocal">6、ThreadLocal<a class="post-anchor" href="#6、ThreadLocal"></a></h3><p>HASH_INCREMENT = 0x61c88647，它可以保证哈希吗均匀的分布在2的N次方数组里<br>每当创建 ThreadLocal 实例时这个值都会增加一个HASH_INCREMENT。</p>
<p>开放地址法</p>
<h3 id="7、ConcurrentHashMap">7、ConcurrentHashMap<a class="post-anchor" href="#7、ConcurrentHashMap"></a></h3><p>数组里面的元素都加锁了</p>
<h2 id="3、基础">3、基础<a class="post-anchor" href="#3、基础"></a></h2><p>1、CAS</p>
<p>无锁算法，不加锁的情况下实现多线程变量的同步。</p>
<p>2、RPC</p>
<p>3、SPI </p>
<p>服务发现</p>
<p>4、hash函数+避免冲突</p>
<p>保证哈希吗均匀的分布</p>
<p>拉链法，hashmap</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ h ^ ( h >>> 16 )  ] & ( n-1 )</span><br></pre></td></tr></tbody></table></figure>

<p>开放地址法</p>
<p>HASH_INCREMENT = 0x61c88647</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocalHashCode & (n-1)</span><br></pre></td></tr></tbody></table></figure>

<p>5、动态代理</p>
<p>jdk-Proxy、InvocationHandler</p>
<p>cglib-Enhancer、Callback</p>
<p>6、生产者消费者模式</p>
<h1 id="2、基础">2、基础<a class="post-anchor" href="#2、基础"></a></h1><h2 id="1、NIO">1、NIO<a class="post-anchor" href="#1、NIO"></a></h2><p>socket</p>
<p>BIO</p>
<p>NIO</p>
<p> select、epoll</p>
<p>轮询select</p>
<p>1024</p>
<p>1、在一个线程里，轮询选择器select()：系统调用，直到有事件才返回，否则一直阻塞；</p>
<p>2、一个选择器会管理多个通道上的事件，当有事件发生时，会从缓冲区拿事件；</p>
<p>比如，ServerSocketChannel会在选择器上注册连接事件，当事件发生时，select会返回，我们可以从缓冲区拿到事件，创建一个SocketChannel，并往选择器上注册一个读写事件……</p>
<p>reactor模型——事件驱动，Reactor 、Acceptor、Handlers </p>
<h2 id="2、HTTP">2、HTTP<a class="post-anchor" href="#2、HTTP"></a></h2><h3 id="http-amp-https-amp-websocket-amp-http2">http & https & websocket & http2<a class="post-anchor" href="#http-amp-https-amp-websocket-amp-http2"></a></h3><p>1、三次握手、四次挥手</p>
<p>2、明文|加密（how） 共享密钥、公开密钥</p>
<p>3、实时更新、冗余数据太多</p>
<p>WS</p>
<p>三次握手之后，客户端发起协议升级的请求：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></tbody></table></figure>

<p>服务器收到之后，会发送101，表示完成了协议的升级：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></tbody></table></figure>

<p>80|443</p>
<p>cache-control、last-modify，if-modify-since、etag、if-match</p>
<p>accept-*</p>
<p>cors</p>
<p>cookie</p>
<h2 id="3、数据库">3、数据库<a class="post-anchor" href="#3、数据库"></a></h2><h4 id="1、结构">1、结构<a class="post-anchor" href="#1、结构"></a></h4><p>页<最小最大记录、页面目录、记录>、行结构、存储引擎、server</p>
<h4 id="2、索引">2、索引<a class="post-anchor" href="#2、索引"></a></h4><p>1、联合索引、聚簇索引、前缀索引</p>
<p>索引部分有效</p>
<p>2、怎么利用索引？</p>
<p><strong>SELECT语句务必指明字段名称</strong>、</p>
<p><strong>使用inner join</strong>、</p>
<p><strong>索引列的类型尽量小</strong>、</p>
<p>超过三张表禁止join、</p>
<p>自增id、</p>
<p><strong>在where子句中应该避免：</strong></p>
<p>​    对字段进行表达式、函数操作 、</p>
<p>​    使用变量、</p>
<p>​    使用!=、<>、</p>
<p>​    使用or、not in、</p>
<p>​    使用空值进行判断，is null</p>
<p>​    使用%ike模糊查询</p>
<p><strong>避免隐式类型转换</strong> 、</p>
<h4 id="3、操作">3、操作<a class="post-anchor" href="#3、操作"></a></h4><h5 id="1、连接">1、连接<a class="post-anchor" href="#1、连接"></a></h5><p>join buffer</p>
<h5 id="2、子查询">2、子查询<a class="post-anchor" href="#2、子查询"></a></h5><p>in子查询</p>
<p>​    半连接、物化、exists</p>
<h4 id="4、MyISAM和InnoDB的区别">4、MyISAM和InnoDB的区别<a class="post-anchor" href="#4、MyISAM和InnoDB的区别"></a></h4><h4 id="5、锁">5、锁<a class="post-anchor" href="#5、锁"></a></h4><p>表锁、行锁、乐观锁、悲观锁）</p>
<h4 id="6、事务">6、事务<a class="post-anchor" href="#6、事务"></a></h4><p>特点，快照读、当前读，隔离级别</p>
<blockquote>
<p>对于不相关的IN子查询来说，如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p>
<p>1、结果集太多，可能内存中都放不下 ；</p>
<p>2、对查询优化器使用索引，就会有问题。 </p>
<p>对于外层查询来说，如果子查询的结果集太多，那就意味着IN子句中的参数特别多，这会导致：</p>
<p>无法有效的使用索引，只能对外层查询进行全表扫描。 </p>
<p>在对外层查询执行全表扫描时，由于IN子句中的参数太多，这会导致检测一条记录 是否符合和IN子句中的参数匹配花费的时间太长。</p>
<p><strong>SQL语句中IN包含的值不应过多，不能超过200个</strong>200个以内查询优化器计算成本时比较精准，超过200 个是估算的成本;另外建议能用between就不要用in，这样就可以使用range索引了；</p>
<p>如果in不能用到索引，可以改成exists看是否能用到索引 ；</p>
</blockquote>
<p>type<index、all、ref、constant、rang>、possible_keys、key、Extra</p>
<p>死锁<mysql有死锁检测、超时机制，如果检测到了死锁，会将其中一个事务回滚调></p>
<p>MVCC<多版本并发控制，指的是普通select根据快照访问版本链的过程></p>
<p><查询和一个规则冲突的其他规则></p>
<h2 id="4、数据结构">4、数据结构<a class="post-anchor" href="#4、数据结构"></a></h2><p>数组、链表、栈、队列、树（二叉树、满二叉树、完全二叉树、二叉查找树、堆）的特性</p>
<p><a href="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183031071.png" data-caption="image-20191212183031071" data-fancybox="images"><img src="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183031071.png" alt="image-20191212183031071"></a></p>
<p><a href="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183103732.png" data-caption="image-20191212183103732" data-fancybox="images"><img src="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183103732.png" alt="image-20191212183103732"></a></p>
<p><a href="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183123197.png" data-caption="image-20191212183123197" data-fancybox="images"><img src="C:%5CUsers%5C19918%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212183123197.png" alt="image-20191212183123197"></a></p>
<a href="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20200203162722419.png" data-caption="image-20200203162722419" data-fancybox="images"><img src="C:\Users\19918\AppData\Roaming\Typora\typora-user-images\image-20200203162722419.png" alt="image-20200203162722419"></a>

<p>——————————————————————————————</p>
<p>二叉查找树</p>
<p>查询最大值/最小值/任意值、插入/删除操作 ——>O(log(n))</p>
<p>平衡二叉树，</p>
<p>——————————————————————————————</p>
<p>堆</p>
<p>查询最大值/最小值 ——>O(1)</p>
<p>查询任意值 ——>O(n)</p>
<p>插入/删除操作 ——>O(log(n))</p>
<p>——————————————————————————————</p>
<p>1、堆排序（最大堆）：</p>
<p>1、创建堆</p>
<p>从最后一个非叶子节点开始依次执行【下沉】操作；</p>
<p>2、排序</p>
<p>循环删除堆顶元素；</p>
<p>并把最后一个元素放到堆顶，执行【下沉】操作；</p>
<p>——————————————————————————————</p>
<p>2、最大优先队列</p>
<p>插入</p>
<p>先放到最后一个位置，执行【上浮】操作；</p>
<p>删除</p>
<p>删除堆顶元素；把最后一个元素放到堆顶，执行【下沉】操作；</p>
<p>——————————————————————————————</p>
<p>二分查找</p>
<h2 id="5、设计模式">5、设计模式<a class="post-anchor" href="#5、设计模式"></a></h2><h3 id="1、创建对象的模式">1、创建对象的模式<a class="post-anchor" href="#1、创建对象的模式"></a></h3><h4 id="1、单例模式">1、单例模式<a class="post-anchor" href="#1、单例模式"></a></h4><p>内存中只有一个实例；</p>
<h4 id="2、-构建者模式">2、==构建者模式==<a class="post-anchor" href="#2、-构建者模式"></a></h4><p>同样的构建过程就可以构建不同的产品。</p>
<h4 id="3、工厂模式">3、工厂模式<a class="post-anchor" href="#3、工厂模式"></a></h4><p>在工厂中创建对象；</p>
<ul>
<li>工厂方法模式：有多个工厂</li>
<li>静态工厂模式：有一个工厂</li>
<li>抽象工厂模式：一个工厂创建多个对象</li>
</ul>
<h3 id="2、结构类的模式">2、结构类的模式<a class="post-anchor" href="#2、结构类的模式"></a></h3><p>组合类或者对象</p>
<h4 id="1、-适配器">1、==适配器==<a class="post-anchor" href="#1、-适配器"></a></h4><p>用来解决两个系统之间接口不兼容的问题。可以把别的系统特殊的、新加的类，封装成我们系统里面一个正在使用的类。这样，我们的系统基本不用修改，所有的调用跟以前一样。</p>
<h4 id="2、代理模式">2、代理模式<a class="post-anchor" href="#2、代理模式"></a></h4><p>使用代理对象增强目标对象的方法，区别是可以条件判断，是否调用目标方法；<br>装饰模式：仅仅侧重增强目标对象的方法；</p>
<h4 id="3、门面模式">3、门面模式<a class="post-anchor" href="#3、门面模式"></a></h4><p>一个供外部访问的接口；外部通过这个接口就可以访问这个系统。可以减少系统间的相互依赖。</p>
<h3 id="3、行为类模式">3、行为类模式<a class="post-anchor" href="#3、行为类模式"></a></h3><h4 id="1、观察者模式">1、观察者模式<a class="post-anchor" href="#1、观察者模式"></a></h4><p>定义对象间一对多的依赖关系，当一个对象发生改变，它所依赖的对象也会受到通知。</p>
<h4 id="2、模板方法模式">2、模板方法模式<a class="post-anchor" href="#2、模板方法模式"></a></h4><p>定义一个框架，将某些步奏的具体实现，放到子类里面去做。</p>
<h4 id="3、责任链模式">3、责任链模式<a class="post-anchor" href="#3、责任链模式"></a></h4><p>==一个请求可以有多个对象处理==，这些对象连成一条链，并沿着这个链传递请求，如果一个对象不能处理，就把这个事件传递到下一个对象，直到有对象可以处理为止。</p>
<h4 id="4、策略模式">4、策略模式<a class="post-anchor" href="#4、策略模式"></a></h4><p>策略封装类不用实现策略接口，可以随意切换不同策略。</p>
<h1 id="3、服务端框架">3、服务端框架<a class="post-anchor" href="#3、服务端框架"></a></h1><h2 id="1、spring">1、spring<a class="post-anchor" href="#1、spring"></a></h2><h3 id="1、基础">1、基础<a class="post-anchor" href="#1、基础"></a></h3><h4 id="1、IoC">1、IoC<a class="post-anchor" href="#1、IoC"></a></h4><p>微观上，Spring ioc容器就是 singletonObjects：</p>
<p>Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);</p>
<p>宏观上，指整个Spring环境，bean工厂：dbMap，处理器、singletonObjects</p>
<h4 id="2、AOP">2、AOP<a class="post-anchor" href="#2、AOP"></a></h4><p>处理横切性的问题，日志记录\事务\异常\权限检查，和主业务逻辑分开，降低耦合、减小重复代码。</p>
<p>使用动态代理对目标方法进行增强</p>
<h5 id="1、术语">1、术语<a class="post-anchor" href="#1、术语"></a></h5><p>1、连接点、切点、增强|通知、切面、织入</p>
<p>2、通知类型</p>
<p>3、execution、@annotation、this、target</p>
<a href="https://uploader.shimo.im/f/oiLgR1txZEEjaTHc.png!thumbnail" target="_blank" rel="noopener" data-caption="img" data-fancybox="images"><img src="https://uploader.shimo.im/f/oiLgR1txZEEjaTHc.png!thumbnail" alt="img"></a>

<h5 id="2、原理">2、原理<a class="post-anchor" href="#2、原理"></a></h5><h6 id="1、初始化">1、初始化<a class="post-anchor" href="#1、初始化"></a></h6><p>@EnableAspectJAutoProxy ——> 注册BeanPostProcessor</p>
<h6 id="2、获取切面的描述信息">2、获取切面的描述信息<a class="post-anchor" href="#2、获取切面的描述信息"></a></h6><p>在bean实例化之前</p>
<h6 id="3、生成代理对象">3、生成代理对象<a class="post-anchor" href="#3、生成代理对象"></a></h6><p>在bean实例化之后；会判断当前类有没有在哪个切点里面；</p>
<p>我们可以看到，</p>
<p>1、默认使用jdk动态代理；</p>
<p>2、但是如果目标类，没有接口，使用的将会是cglib；</p>
<p>3、如果目标类有接口，要使用cglib，可以修改proxyTargetClass=true，<code>@EnableAspectJAutoProxy(proxyTargetClass = true)。</code> </p>
<h4 id="3、事务的传播行为">3、事务的传播行为<a class="post-anchor" href="#3、事务的传播行为"></a></h4><p>1、required</p>
<p>2、requires_new</p>
<p>3、mandatory 强制的</p>
<p>4、never</p>
<p> 5、supports</p>
<p>6、not_supported</p>
<h4 id="4、其他">4、其他<a class="post-anchor" href="#4、其他"></a></h4><h5 id="1、ApplicationContext和BeanFactory区别">1、ApplicationContext和BeanFactory区别<a class="post-anchor" href="#1、ApplicationContext和BeanFactory区别"></a></h5><p>ApplicationEventPublisher（消息发送）、ResourceLoader（加载资源）</p>
<h5 id="2、BeanFactory和FactoryBean">2、BeanFactory和FactoryBean<a class="post-anchor" href="#2、BeanFactory和FactoryBean"></a></h5><p>当一个类的依赖关系很复杂的时候，但是我们想对外提供一个简单方式，方便外部快速获取到，可以使用FactoryBean。</p>
<p>比如，</p>
<p>SqlSessionFactory ————>  SqlSessionFactoryBean ，配置类Configuration</p>
<p>T ————> ReferenceBean，消费者</p>
<h5 id="3、循环引用">3、循环引用<a class="post-anchor" href="#3、循环引用"></a></h5><p>singletonFactories、singletonObjects</p>
<p>4、事件？</p>
<p>怎么找？怎么给它？查找目标对象的方式：byname、bytype</p>
<p>属性注入的方式：set方法、构造器、field（反射） </p>
<p>AUTOWIRE_NO ：默认不自动装配，@autowire注解调仍然会自动装配。</p>
<p>AUTOWIRE_BY_NAME：根据名字自动装配。AUTOWIRE_BY_TYPE：根据类型自动装配。 </p>
<h3 id="2、扩展点">2、扩展点<a class="post-anchor" href="#2、扩展点"></a></h3><ol>
<li><p>@Import引入的两种接口：</p>
<ul>
<li>ImportSelector（Spring Boot 自动装配，引入AOP的BeanPostProcessor）、</li>
<li>ImportBeanDefinitionRegistrar（mybatis注册mapper，MapperFactoryBean）</li>
</ul>
</li>
<li><p>后置处理器</p>
<p>1、ConfigurationClassPostProcessor（BeanDefinitionRegistryPostProcessor）</p>
<p>​    1、扫描包，并把bean注册给beanFactory。</p>
<p>​    2、回调@Import相关的接口，注册@import引入的类。</p>
<p>​    3、为@Configuration类生成一个cglib代理。</p>
<p>2、BeanPostProcessor：在bean实例化之后、放到bean容器之前、插手bean的实例化过程</p>
<p>​        bean的生命周期回调、AOP</p>
</li>
</ol>
<p>   3、spring.factories</p>
<p>   ​    </p>
<h3 id="3、springMVC流程">3、springMVC流程<a class="post-anchor" href="#3、springMVC流程"></a></h3><p>web框架，实现了一些servlet的API；</p>
<p>ServletContainerInitializer#onStartUp|WebApplicationInitializer、</p>
<p>Servlet#init</p>
<p>Servlet#service</p>
<h4 id="1、初始化DispacherServlet">1、初始化DispacherServlet<a class="post-anchor" href="#1、初始化DispacherServlet"></a></h4><h5 id="1、-lt-cinit-gt-——">1、< cinit> ——<a class="post-anchor" href="#1、-lt-cinit-gt-——"></a></h5><p>加载DispatcherServlet.properties;</p>
<h5 id="2、-lt-Servlet-init-gt-——">2、<Servlet#init>——<a class="post-anchor" href="#2、-lt-Servlet-init-gt-——"></a></h5><p>1、调用容器的onRefresh方法；</p>
<p>2、从上面这个对象中读取MultipartResolver、HandlerMapping、ViewResolver，设置给DispacherServlet……；</p>
<h4 id="2、初始化HandlerMapping">2、初始化HandlerMapping<a class="post-anchor" href="#2、初始化HandlerMapping"></a></h4><p>RequestMappingHandlerMapping（InitializingBean#afterPropertiesSet）</p>
<p><RequestMappingInfo：HandlerMethod></p>
<h4 id="3、处理请求">3、处理请求<a class="post-anchor" href="#3、处理请求"></a></h4><p>匹配、反射调用</p>
<p>Servlet#service ——> DispatcherServlet#doDispatch</p>
<p>4、渲染</p>
<p>InternalResourceViewResolver </p>
<h3 id="4、springboot">4、springboot<a class="post-anchor" href="#4、springboot"></a></h3><p>是一种快速使用spring的方式</p>
<h4 id="1、约定大于配置、内嵌tomcat">1、约定大于配置、内嵌tomcat<a class="post-anchor" href="#1、约定大于配置、内嵌tomcat"></a></h4><h4 id="2、自动装配">2、自动装配<a class="post-anchor" href="#2、自动装配"></a></h4><p>—— @EnableAutoConfiguration、ImportSelect接口、META-INF/spring.factories、</p>
<h4 id="3、起步依赖">3、起步依赖<a class="post-anchor" href="#3、起步依赖"></a></h4><p> —— 比如，mybatis-spring-boot-starter、</p>
<h4 id="4、启动流程">4、启动流程<a class="post-anchor" href="#4、启动流程"></a></h4><p>1、SpringApplication#<em>run</em>  —— 创建容器 ——</p>
<p>2、——OnRefresh —— 启动tomcat——</p>
<p>​    —— 回调ServletContainerInitializer#onStartUp，设置dispatcherservlet</p>
<p>​    ——Servlet#init、</p>
<h2 id="2、mybatis">2、mybatis<a class="post-anchor" href="#2、mybatis"></a></h2><h4 id="1、JDBC">1、JDBC<a class="post-anchor" href="#1、JDBC"></a></h4><h4 id="2、持久层框架">2、持久层框架<a class="post-anchor" href="#2、持久层框架"></a></h4><p>避免sql语句硬编码、避免结果集解析的硬编码、连接池</p>
<h4 id="3、动态sql">3、<a href="https://zhuanlan.zhihu.com/p/82693333" target="_blank" rel="noopener">动态sql</a><a class="post-anchor" href="#3、动态sql"></a></h4><p>where、trim、if、foreach、#{}、${}——逻辑判断、动态拼接 sql  【【【【<a href="https://zhuanlan.zhihu.com/p/82693333" target="_blank" rel="noopener">ognl</a>】】】</p>
<p>主键自增、缓存、</p>
<p>延迟加载：会创建关联对象的代理对象，只有在关联对象被执行的时候，才去执行相关的sql；</p>
<p>TypeHandler —— 映射Java对象到表的某一列上</p>
<p>Interceptor ，@Intercepts，指定拦截的类型、方法和参数列表</p>
<p>插件</p>
<p>——Interceptor、@Intercepts，</p>
<p>Executor插件：</p>
<p>以SimpleExecutor作为target，在获取sqlSession的时候，会遍历所有实现Interceptor接口的类，取出@Intercepts注解，并拿注解上配置的type和target的接口类型做对比，如果一致，则使用这个类为target创建一个jdk动态代理对象，并返回。</p>
<p>在调用的时候，会判断：如果为目标方法设置了插件，会调这些插件，</p>
<h4 id="4、流程">4、流程<a class="post-anchor" href="#4、流程"></a></h4><h5 id="1、初始化-1">1、初始化<a class="post-anchor" href="#1、初始化-1"></a></h5><p>SqlSessionFactory</p>
<p>——> SqlSession</p>
<p>——> T <MapperProxyFactory、MapperProxy<sqlsession>></sqlsession></p>
<p>MappedStatement、MapperProxyFactory</p>
<h5 id="2、执行">2、执行<a class="post-anchor" href="#2、执行"></a></h5><p>代理对象—— 得到<参数名：参数值>映射关系，主要是根据参数的顺序。</p>
<p>SqlSession——SqlSession#select —— 得到MappedStatement<strong>、</strong>执行executor</p>
<h4 id="5、mybatis-spring">5、mybatis-spring<a class="post-anchor" href="#5、mybatis-spring"></a></h4><p>SqlSessionFactoryBean、MapperFactoryBean</p>
<p>可以把Java对象变成sql语句中的参数；也可以把sql语句执行的结果封装成Java对象；</p>
<p>封装了加载驱动、创建连接、创建statement、执行statement、映射结果集的过程。</p>
<p>模糊查询 like 语句该怎么写 ？</p>
<p>1）在 java 中拼接通配符，通过#{}赋值 </p>
<p><code>LIKE CONCAT('%',#{name},'%')</code></p>
<p>2）在 Sql 语句中拼接通配符 （不安全 会引起 Sql 注入） </p>
<p><code>like '%${name}%'</code></p>
<p>truncate、insert</p>
<h2 id="3、dubbo">3、dubbo<a class="post-anchor" href="#3、dubbo"></a></h2><p>1、SPI  、依赖注入（ ExtensionFactory、SpiExtensionFactory、SpringExtensionFactory）</p>
<p>2、调用流程：</p>
<p>服务调用：<strong>MockClusterInvoker</strong></p>
<p>服务导出（Invoker：ProxyFactory#getInvoker（javassit），Protocol#export）、</p>
<p>服务发现（Invoker：Protocol#refer，ProxyFactory#getProxy（javassit——jdk动态代理）</p>
<p>客户端的代理对象(jdk代理)——>Invoker——>netty_________netty——>Invoker(Wrapper)——>服务端的真实对象</p>
<p>路由：调用的时候过滤调哪些机器</p>
<p>负载均衡：随机、轮询、相同调用数 随机、hash</p>
<p>容错：</p>
<p>协议：dubbo（NIO、长连接、hessian）、http、rest。。。</p>
<p>注册中心：ZK、redis。。。</p>
<p>ExtensionFactory</p>
<h2 id="4、tomcat">4、tomcat<a class="post-anchor" href="#4、tomcat"></a></h2><h2 id="5、zookeeper">5、zookeeper<a class="post-anchor" href="#5、zookeeper"></a></h2><h4 id="1、简介">1、简介<a class="post-anchor" href="#1、简介"></a></h4><p>服务治理</p>
<p>ZAB协议、领导者选举、写操作、</p>
<h4 id="2、持久化">2、持久化<a class="post-anchor" href="#2、持久化"></a></h4><p>（10 0000）、</p>
<h4 id="3、集群">3、集群<a class="post-anchor" href="#3、集群"></a></h4><p>集群的角色、节点的类型（节点之间是相互有序的，会自动在节点后面加一个整型数）、watch机制、</p>
<p>脑裂</p>
<h4 id="4、使用">4、使用<a class="post-anchor" href="#4、使用"></a></h4><p>分布式锁（Curator）、配置中心、命名服务                                                                  </p>
<h2 id="6、redis">6、redis<a class="post-anchor" href="#6、redis"></a></h2><h4 id="1、简介-1">1、简介<a class="post-anchor" href="#1、简介-1"></a></h4><p>nosql、内存运行、单线程、IO多路复用、数据类型、|| 内存淘汰机制、过期策略</p>
<p>内存淘汰机制：volatile-lru：对设置了过期时间的key， 删除 最近最少使用的key（默认值）；allkeys-lru ： 对所有的key， 删除 最近最少使用的；volatile-random：对设置了过期时间的key，随机的删除 key；allkeys-random： 对所有的key，随机删除；volatile-ttl ： 删除即将过期的noeviction ： 永不过期，返回错误</p>
<p>事务，watch机制</p>
<p>1、避免使用keys <em>2、设置key有效期*</em>3、想要一次添加多条数据的时候可以使用管道**</p>
<h4 id="2、持久化-1">2、持久化<a class="post-anchor" href="#2、持久化-1"></a></h4><p>rdb、aof、混合持久化</p>
<h4 id="3、数据类型">3、数据类型<a class="post-anchor" href="#3、数据类型"></a></h4><p>range、push、pop</p>
<h4 id="3、集群-1">3、集群<a class="post-anchor" href="#3、集群-1"></a></h4><p>主从模式（runid、offset）、哨兵模式、集群</p>
<p>（主从切换数据丢失——异步复制、脑裂，min-slave-to-write）</p>
<p>psync <runid> <offset></offset></runid></p>
<p>缓冲区：主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区，默认1M ；</p>
<p>offset：主节点向从节点传递的字节数；</p>
<h4 id="4、使用-1">4、使用<a class="post-anchor" href="#4、使用-1"></a></h4><p>缓存、分布式锁</p>
<p>redis集群的哈希槽算法：哈希槽的个数是个固定值 16384  2^14</p>
<h2 id="7、netty">7、netty<a class="post-anchor" href="#7、netty"></a></h2><p>netty</p>
<p>每个channel收到的IO事件，都会沿着一个链传递到每个ChannelHandler上，我们需要做的就是定义自己的ChannelHandler</p>
<h2 id="8、其他">8、其他<a class="post-anchor" href="#8、其他"></a></h2><hr>
<hr>
<p>4、客户端 — 待续</p>
<p>1、web</p>
<p>2、android</p>
<p>$$<br>1+2+3+…+n\leq n^{2}<br>$$</p>
<p>$$<br>n+\frac{n}{2}+\frac{n}{4}+…\leq2n<br>$$</p>
</body></html>

  
  <div class="post-guide">
    <div class="item left">
        
    </div>
    <div class="item right">
        
          <a href="/2020/05/12/hello-world/">Hello World</a>
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://ibingdian.github.io">冰点</a>
    </div>
    <div class="link">
      永久链接：<a href="https://ibingdian.github.io/2020/05/12/Java%E9%9D%A2%E8%AF%95/">https://ibingdian.github.io/2020/05/12/Java%E9%9D%A2%E8%AF%95/</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://ibingdian.github.io">冰点</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
        <footer>
          <div class="copyright">
            ©2020
            <a href="https://ibingdian.github.io">冰点</a> Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> |
            <a href="https://github.com/shixiaohu2206/hexo-theme-huhu" target="_blank" rel="noopener">hexo-theme-huhu</a>
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","pagemap":"pagemap.min","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script>  
